<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BoundToMSA" xml:space="preserve">
    <value>Bound to MSA: {0}</value>
    <comment>Formatting string for the MSA field of a lease</comment>
  </data>
  <data name="BoundToSID" xml:space="preserve">
    <value>Bound to SID: {0}</value>
    <comment>Formatting string for the SID field of a lease</comment>
  </data>
  <data name="Category" xml:space="preserve">
    <value>Category: {0}</value>
    <comment>Formatting string for the category of a key</comment>
  </data>
  <data name="ContentId" xml:space="preserve">
    <value>ContentId: {0}</value>
    <comment>Format string to specify the content id</comment>
  </data>
  <data name="ExpirationDate" xml:space="preserve">
    <value>Expiration: {0}</value>
    <comment>Formatting string for the expiration field of a key or lease</comment>
  </data>
  <data name="GeneralFailure" xml:space="preserve">
    <value>The command failed with exception: {0}</value>
    <comment>Generic error for failures from exceptions.</comment>
  </data>
  <data name="Invalid" xml:space="preserve">
    <value>Invalid: 0x{0:X8}</value>
    <comment>Format string for an invalid key or lease state</comment>
  </data>
  <data name="IssueDate" xml:space="preserve">
    <value>Issued: {0}</value>
    <comment>Formatting string for the issue date of a key or lease</comment>
  </data>
  <data name="Leases" xml:space="preserve">
    <value>Leases</value>
    <comment>The name of multiple leases</comment>
  </data>
  <data name="LicenseId" xml:space="preserve">
    <value>Id: {0}</value>
    <comment>Formatting string for the Id field of a key or lease</comment>
  </data>
  <data name="LicenseNotFound" xml:space="preserve">
    <value>There is no key or lease installed for {0}</value>
    <comment>Error for when no key or lease is found for a given package family name</comment>
  </data>
  <data name="NoExpiration" xml:space="preserve">
    <value>(none)</value>
    <comment>String to indicate a key or lease has no expiration</comment>
  </data>
  <data name="NoIssueDate" xml:space="preserve">
    <value>(none)</value>
    <comment>String to indicate the key or lease has no issue date</comment>
  </data>
  <data name="NotRunningAsAdmin" xml:space="preserve">
    <value>Access Denied.  You need to run this command as admin.</value>
    <comment>Error when trying to run a command that requires admin priviledges.</comment>
  </data>
  <data name="PackageFamilyName" xml:space="preserve">
    <value>Package Family Name: {0}</value>
    <comment>Format string to specify the package family name for a key</comment>
  </data>
  <data name="PackageFamilyNames" xml:space="preserve">
    <value>Package Family Names: {0}</value>
    <comment>Format string to specifiy the package family names a lease covers</comment>
  </data>
  <data name="RequiresLease" xml:space="preserve">
    <value>Requires lease: {0}</value>
    <comment>Format string for the RequiresLease field of a key</comment>
  </data>
  <data name="SuccessMessage" xml:space="preserve">
    <value>The command completed successfully.</value>
    <comment>Generic success message for commands.</comment>
  </data>
  <data name="SuccessWithRebootMessage" xml:space="preserve">
    <value>The command completed successfully but requires a reboot to take effect.</value>
    <comment>Generic success message for commands that require a reboot.</comment>
  </data>
  <data name="UnableToGetLicense" xml:space="preserve">
    <value>Unable to get key or lease for {0}, exception {1}.</value>
    <comment>Generic error for when no key or lease can be read</comment>
  </data>
  <data name="Valid" xml:space="preserve">
    <value>Valid</value>
    <comment>String for a valid key or lease state</comment>
  </data>
  <data name="Validity" xml:space="preserve">
    <value>Validity: {0}</value>
    <comment>Format string for the Validity field of a key or lease</comment>
  </data>
</root>